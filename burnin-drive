#!/bin/bash

# burnin-drive
#
# MIT License
#
# Copyright (c) 2019 Samuel Kadolph
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

function find_make {
                      make=$(echo "$1" | sed -nr 's/^Vendor: +(.*)$/\1/p')
  [[ -z "$make" ]] && make=$(echo "$1" | sed -nr 's/^Device Model: +([^ ]+)/\1/p')
  [[ -z "$make" ]] && make=$(echo "$1" | sed -nr 's/^Model Number: +([^ ]+)/\1/p')

  echo "$make"
}

function find_model {
                       model=$(echo "$1" | sed -nr 's/^Product: +(.*)$/\1/p')
  [[ -z "$model" ]] && model=$(echo "$1" | sed -nr 's/^Device Model: +[^ ]+ +(.*)$/\1/p')
  [[ -z "$model" ]] && model=$(echo "$1" | sed -nr 's/^Model Number: +[^ ]+ +(.*)$/\1/p')

  echo "$model" | sed 's/ /-/g'
}

function find_serial {
  serial=$(echo "$1" | sed -nr 's/^Serial [Nn]umber: +(.*)$/\1/p')

  echo "$serial"
}

function my_smartctl {
  smartctl $@ | sed '/^smartctl/d;/^Copyright/d;/^===/d' | sed '1d;${/^$/d;}' | puts
}

function poll_smart_test {
  puts "Waiting for SMART Test to finish"

  while true; do
    if smartctl --log selftest "$dev" | grep "# 1" | grep -v "Self test in progress" >/dev/null; then
      return
    fi

    if [[ "$1" == "long" ]]; then
      sleep $SMART_LONG_POLL
    else
      sleep $SMART_SHORT_POLL
    fi
  done
}

function puts {
  if [[ -t 0 ]]; then
    echo "$@" | sed "s/^/$(date '+%Y-%m-%d %H:%M:%S %Z') | /"
  else
    sed "s/^/$(date '+%Y-%m-%d %H:%M:%S %Z') | /"
  fi
}

function run_badblocks {
  puts "===== Start badblocks on $dev"

  if [[ "$RUN" == "1" ]]; then
    badblocks -wsv -b 4096 -o "$bb_file" "$dev" 2>&1
  else
    puts "Not running badblocks because this is a dry run"
  fi

  puts "===== Finish badblocks on $dev"
}

function run_smart_test {
  puts "===== Start SMART ${1^} Test on $dev"

  if [[ "$RUN" == "1" ]]; then
    my_smartctl --test $1 "$dev"
    poll_smart_test
    puts "SMART Test finished"
  else
    puts "Not running SMART test because this is a dry run"
  fi

  show_smart_data $2

  puts "===== Finish SMART ${1^} Test on $dev"
}

function show_smart_data {
  my_smartctl --health "$dev"
  puts
  my_smartctl --attributes "$dev"
  puts
  my_smartctl --log error "$dev"
  puts
  my_smartctl --log selftest "$dev"
}

function usage {
  echo "usage: $0 [-d|--dir output_dir] [-m|--dry-run] [-l|--log log_file] [-r|--run] [-y|--yes] drive" 1>&2
}

CONSENT=${CONSENT:-0}
DIR=${DIR:-$(pwd)}
LOG=${LOG:-auto}
RUN=${RUN:-0}
SMART_LONG_POLL=$((15*60))
SMART_SHORT_POLL=30

args=""

while (( "$#" )); do
  case "$1" in
    -d|--dir)
      DIR=$2
      shift 2
      ;;
    -m|--dry-run)
      RUN=0
      shift
      ;;
    -l|--log)
      LOG=$2
      shift 2
      ;;
    -r|--run)
      RUN=1
      shift
      ;;
    -y|--yes)
      CONSENT=1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*|--*=)
      echo "unknown flag $1" 1>&2
      usage ""
      exit 1
      ;;
    *)
      args="$args $1"
      shift
      ;;
  esac
done

eval set -- "$args"

if [[ $# -ne 1 ]]; then
  echo "drive name must be provided" 1>&2
  usage
  exit 1
fi

dev="/dev/$1"

if [[ ! -e "$dev" ]]; then
  echo "could not find device $dev" 1>&2
  exit 1
fi

smartinfo=$(smartctl -i /dev/$1)

make=$(find_make "$smartinfo")
model=$(find_model "$smartinfo")
serial=$(find_serial "$smartinfo")

if [[ -z "$make" ]] || [[ -z "$model" ]] || [[ -z "$serial" ]]; then
  echo "unable to determine drive make, model, and serial" 1>&2
  exit 1
fi

if [[ "$CONSENT" != "1" ]]; then
  echo "This script will erase all data on $dev. Any other processes trying to use it will fail."
  echo "The make, model, and serial for this drive is $make $model $serial. Confirm this is the right drive."
  echo "And you really really really should be running this inside of screen or tmux."
  read -p "Are you sure you wish to proceed? [yN] " -n 1 -r

  [[ "$REPLY" != "" ]] && echo;

  if [[ "${REPLY^^}" != "Y" ]]; then
    echo "Aborting..."
    exit 1
  fi
fi

if [[ "$LOG" == "auto" ]]; then
  bb_file="$DIR/burnin_${1}_${make}_${model}_${serial}.badblocks"
  log_file="$DIR/burnin_${1}_${make}_${model}_${serial}.log"
else
  bb_file="$DIR/$LOG.badblocks"
  log_file="$DIR/$LOG.log"
fi

[[ ! -d "$DIR" ]] && mkdir -p "$DIR"

rm -f "$bb_file"
rm -f "$log_file"

exec 1> >(tee "$log_file")

puts "Device: $1"
puts "Make: $make"
puts "Model: $model"
puts "Serial: $serial"
puts "badblocks File: $bb_file"
puts "Log File: $log_file"
puts "Passes: $PASSES"
puts "Dry Run: $([ "$RUN" == 1 ] && echo "No" || echo "Yes")"

run_smart_test short
run_badblocks
run_smart_test short
run_smart_test long
